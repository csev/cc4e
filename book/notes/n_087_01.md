In this section we are talking about the "pre-processor".  It is probably a good time to 
talk a bit about why we use this terminology. For those of you with a Computer Science 
degree from "back in the day", many of you wrote a compiler as a senior project (just like I 
did). Building a compiler was a great project because part of the goal of Computer Science 
is to understand the technologies that make programming possible from the language syntax 
down to the hardware.  The compiler that translates our source code into machine code is an 
essential part of that technology stack.

Early compilers for languages like the early FORTRAN variants tended to be "translators" - 
they translated code one line at a time from the high level language to the assembly 
language.  You could think of early FORTRAN programs in the 1950's and 1960's as just more 
convienent ways to write assembly language for programmers that knew assembly language.  You 
needed to be away of assembly language and the translation that was going on to write fast 
FORTRAN.  Programs were small and optimization was done at the FORTRAN level, often leading 
to some hard-to-understand code.

By the mid 1970's programming languages were based on parsing theory and we used what is 
called a "grammar" to define a language.  Kernighan and Ritchie kept I/O statements out of 
the C language to keep its formal description (i.e. its grammar) as simple as possible.  As 
these new languages emerged, they allowed for a more theoretical and powerful approach to 
converting source code to machine language.

The theoretical advances in compiler and language design meant that parts of a compiler 
might be reusable across multiple programming languages - each language would have its own 
syntax and "grammar rules" and they would be plugged into a compiler and "poof" you had a 
new programming language.

It got to the point where UNIX systems had a tool called 'yacc' which stood for "Yet Another 
Compiler Compiler" - you would give it a grammar for your "new" language and it would make a 
compiler for you.  As a matter of fact, the JavaScript languages was created in 10 days back 
in 1995 because Brendan Eich had a lot of experience with "compiler generators".  He defined 
a grammar for JavaScript and generated his first compiler.

Part of what made a "compiler generator" possible was the idea of a multi-step compiler - 
where the tasks of a compiler were broken down into a series of simpler and more well 
defined steps.  Here are the steps of a typical C compiler in the 1970's:

* A preprocessor step that takes C code with syntax like `#define` and `#include` as its 
input and produces raw C code output with those instructions processed.  The preprocessor 
was a C to C transformation.

* A parser step that took the raw C code, applied the grammar to the language and created 
what is called a "parse tree".  Think of the tree as a hierarchy of statements, grouped into 
blocks, grouped into functions etc. - Things like loops are just nodes in the parse tree.

* A code generation step that turns the parse tree into some kind of simplistic internal 
code that expanded things like loops and if-then-else statements into code

* A code optimization step that looked at the internal code, and moved things around and 
eliminated any redundant computations (i.e. don't compute the same thing twice).  This step 
is why the authors make such a big fuss about how there are times where C might do things in 
a slightly different order in an expression even in the presence of parenthesis.  Remember 
the "K&R C Rearrangement License" back in Chapter 2?  That rule removes constraints on the 
compiler's optimization step so it can generate the most efficient code.

* I would note that all of the steps up to this point do not depend in any way on the actual 
machine language of the system they were running on.  This meant that a preprocessor, 
parser, code generator, and code optimizer could be written in C and used on any 
architecture.

* A "code generator" step takes the optimized intermediate code and generates the actual 
assembly and then machine language for the processor.  For fun, you can add the `-s` 
parameter to your C compiler and see the resulting assembly language output for your system.  
If you look at the machine language generated on an `Intel` or `AMD` processor and compare 
it to the machine language on an ARM processor, it will look very different.

Because all but the final compiler steps above do not depend on the computer where the 
program is being run, you could create a C compiler on a new computer architecture by 
writing a code generator on the new computer, then running all but the last step of the 
compiler on one computer, then copying the internal code generated by the compiler to the 
new computer and running the code generation step.  Then you have a working C compiler on 
the new computer and can re-compile the C compiler itself from source code and produce a 
fully-native C compiler on the new computer that can compile all of the rest of the C code 
(including possibly the portable elements of UNIX) on the new computer.

Yes - describing how to cross-compile and bootstrap a C compiler onto a new computer 
hardware architecture can give you a headache if you think about it too much.  But this 
notion of bootstrapping a C compiler onto a new architecture was an important technique to 
move C and then UNIX to a wide range of very different computer architectures.  We see this 
in action as the UNIX-like MacOS operating system over the past 20 years was delivered 
initially on Motorola processors, then on PowerPC processors, then on Intel processors and 
most recently on ARM-based processors built by Apple.  Using the software portability 
patterns that come from C and UNIX and described by Kernighan and Ritchie in this book, 
Apple now makes their own hardware that can be tuned and evolved over time as their 
operating system and application requirements dictate.

The use of a grammar to define a programming language is one of the reasons that syntax 
errors are so obtuse.  The compiler is not looking at your code like a human - it is just 
following a set of rules to parse your code and it is stuck with something illogical and 
gives you a message like "Unexpected statement, block or constant on line 17" and the error 
is nowhere near line 17.

Modern compilers are more sophisticated than the steps above - but these steps give you a 
sense that a compiler does many things to make it so your code can actually run efficiently.

And given that Kernighan and Ritchie were building a programming language C, a mostly 
portable operating system written in C (UNIX), and a mostly portable C compiler written in C 
- some of their innovative work and research into compiler design finds its way into this 
book and so we have a section in this chapter called "The C Pre Processor".


